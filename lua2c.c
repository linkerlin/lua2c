/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: NOTIMPL
 * function(s) */
static int lcf1_NOTIMPL (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* error('FIX - NOT IMPLEMENTED: ' .. s, 2) */
  lc_getupvalue(L,lua_upvalueindex(1),4,1);
  lua_pushliteral(L,"FIX - NOT IMPLEMENTED: ");
  lua_pushvalue(L,1);
  lua_concat(L,2);
  lua_pushnumber(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 1);
  return 0;
}


/* name: DEBUG
 * function(...) */
static int lcf1_DEBUG (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local ts = {...} */
  lua_createtable(L,1,0);
  const int lc6 = lua_gettop(L);
  {int i; for (i=lc_nformalargs+1; i<=lc_nactualargs; i++) { lua_pushvalue(L, i); }}
  while ((lua_gettop(L) > lc6)) {
    lua_rawseti(L,lc6,(0 + (lua_gettop(L) - lc6)));
  }
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* for i,v in ipairs(ts) do
   * internal: local f, s, var = explist */
  enum { lc7 = 1 };
  lc_getupvalue(L,lua_upvalueindex(1),2,3);
  lua_pushvalue(L,(1 + lc_nextra));
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local i with idx 5
     * internal: local v with idx 6 */
    
    
    /* ts[i] = table.tostring(v,'nohash',60) */
    lc_getupvalue(L,lua_upvalueindex(1),1,4);
    lua_pushliteral(L,"tostring");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,(6 + lc_nextra));
    lua_pushliteral(L,"nohash");
    lua_pushnumber(L,60);
    lua_call(L,3,1);
    lua_pushvalue(L,(5 + lc_nextra));
    lua_insert(L,-2);
    lua_settable(L,(1 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 6);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,(lc7 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* io.stderr:write(table.concat(ts, ' ') .. '\n') */
  lc_getupvalue(L,lua_upvalueindex(1),3,2);
  lua_pushliteral(L,"stderr");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"write");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),1,4);
  lua_pushliteral(L,"concat");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(1 + lc_nextra));
  lua_pushliteral(L," ");
  lua_call(L,2,1);
  lua_pushliteral(L,"\n");
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 1);
  return 0;
}


/* name: string_to_ast
 * function(src) */
static int lcf1_string_to_ast (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local  lx  = mlp.lexer:newstream (src) */
  lc_getupvalue(L,lua_upvalueindex(1),0,5);
  lua_pushliteral(L,"lexer");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"newstream");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 2);
  
  /* local  ast = mlp.chunk (lx) */
  lc_getupvalue(L,lua_upvalueindex(1),0,5);
  lua_pushliteral(L,"chunk");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* return ast */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  lua_checkstack(L,33);
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -- lua2c.lua - Driver for lua2c - converts Lua 5.1 source to C code.
   * --
   * -- STATUS:
   * --   WARNING: This code passes much of the Lua 5.1 test suite,
   * --   but there could still be errors.  In particular, a few
   * --   language features (e.g. coroutines) are not implemented.
   * --
   * --   Unimplemented Lua language features:
   * --    - deprecated old style vararg (arg) table inside vararg functions
   * --      (LUA_COMPAT_VARARG)
   * --    - debug.getinfo(f, 'n').name for C-based functions
   * --    - setfenv does not permit C-based functions
   * --    - how well do tail call optimizations work?
   * --    - how to handle coroutines? (see README)
   * --    Note: A few things (coroutines) might remain
   * --      unimplemented--see README file file for details.
   * --
   * --   Possible improvements:
   * --    - Fix: large numerical literals can give gcc warnings such as
   * --      'warning: integer constant is too large for "long" type').
   * --      Literal numbers are rendered as C integers literals (e.g. 123)
   * --      rather than C double literals (eg. 123.0).  
   * --    - improved debug tracebacks on exceptions
   * --    - See items marked FIX in below code.
   * --
   * -- SOURCE:
   * --
   * --   http://lua-users.org/wiki/LuaToCee
   * --
   * --   (c) 2008 David Manura.  Licensed in the same terms as Lua (MIT license).
   * --   See included LICENSE file for full licensing details.
   * --   Please post any patches/improvements.
   * --
   * local _G           = _G */
  lua_getfield(L,LUA_ENVIRONINDEX,"_G");
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local assert       = _G.assert */
  lua_pushliteral(L,"assert");
  lua_gettable(L,(1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* local error        = _G.error */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 3 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_pushliteral(L,"error");
  lua_gettable(L,(1 + lc_nextra));
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* local io           = _G.io */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc2 = 4 };
  assert((lua_gettop(L) == (lc2 + lc_nextra)));
  lua_pushliteral(L,"io");
  lua_gettable(L,(1 + lc_nextra));
  lua_rawseti(L,(lc2 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* local ipairs       = _G.ipairs */
  lc_newclosuretable(L,(lc2 + lc_nextra));
  enum { lc3 = 5 };
  assert((lua_gettop(L) == (lc3 + lc_nextra)));
  lua_pushliteral(L,"ipairs");
  lua_gettable(L,(1 + lc_nextra));
  lua_rawseti(L,(lc3 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* local os           = _G.os */
  lua_pushliteral(L,"os");
  lua_gettable(L,(1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* local package      = _G.package */
  lua_pushliteral(L,"package");
  lua_gettable(L,(1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* local require      = _G.require */
  lua_pushliteral(L,"require");
  lua_gettable(L,(1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* local string       = _G.string */
  lua_pushliteral(L,"string");
  lua_gettable(L,(1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 9);
  
  /* local table        = _G.table */
  lc_newclosuretable(L,(lc3 + lc_nextra));
  enum { lc4 = 10 };
  assert((lua_gettop(L) == (lc4 + lc_nextra)));
  lua_pushliteral(L,"table");
  lua_gettable(L,(1 + lc_nextra));
  lua_rawseti(L,(lc4 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* package.path = './lib/?.lua;' .. package.path */
  lua_pushliteral(L,"./lib/?.lua;");
  lua_pushliteral(L,"path");
  lua_gettable(L,(7 + lc_nextra));
  lua_concat(L,2);
  lua_pushliteral(L,"path");
  lua_insert(L,-2);
  lua_settable(L,(7 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* -- note: includes gg/mlp Lua parsing Libraries taken from Metalua.
   * require "lexer" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"lexer");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* require "gg" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"gg");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* require "mlp_lexer" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"mlp_lexer");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* require "mlp_misc" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"mlp_misc");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* require "mlp_table" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"mlp_table");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* require "mlp_meta" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"mlp_meta");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* require "mlp_expr" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"mlp_expr");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* require "mlp_stat" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"mlp_stat");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* require "mlp_ext" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"mlp_ext");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* _G.mlc = {} */
  lua_newtable(L);
  lua_pushliteral(L,"mlc");
  lua_insert(L,-2);
  lua_settable(L,(1 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* -- make gg happy
   * local mlp = assert(_G.mlp) */
  lc_newclosuretable(L,(lc4 + lc_nextra));
  enum { lc5 = 11 };
  assert((lua_gettop(L) == (lc5 + lc_nextra)));
  lua_pushvalue(L,(2 + lc_nextra));
  lua_pushliteral(L,"mlp");
  lua_gettable(L,(1 + lc_nextra));
  lua_call(L,1,1);
  lua_rawseti(L,(lc5 + lc_nextra),5);
  assert(lua_gettop(L) - lc_nextra == 11);
  
  /* local A2C = require "lua2c.ast2cast" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"lua2c.ast2cast");
  lua_call(L,1,1);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* local C2S = require "lua2c.cast2string" */
  lua_pushvalue(L,(8 + lc_nextra));
  lua_pushliteral(L,"lua2c.cast2string");
  lua_call(L,1,1);
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* local function NOTIMPL(s)
   *   error('FIX - NOT IMPLEMENTED: ' .. s, 2)
   * end */
  lua_pushvalue(L,(lc5 + lc_nextra));
  lua_pushcclosure(L,lcf1_NOTIMPL,1);
  assert(lua_gettop(L) - lc_nextra == 14);
  
  /* local function DEBUG(...)
   *   local ts = {...}
   *   for i,v in ipairs(ts) do
   *     ts[i] = table.tostring(v,'nohash',60)
   *   end
   *   io.stderr:write(table.concat(ts, ' ') .. '\n')
   * end */
  lua_pushvalue(L,(lc5 + lc_nextra));
  lua_pushcclosure(L,lcf1_DEBUG,1);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* -- Converts Lua source string to Lua AST (via mlp/gg)
   * local function string_to_ast(src)
   *   local  lx  = mlp.lexer:newstream (src)
   *   local  ast = mlp.chunk (lx)
   *   return ast
   * end */
  lua_pushvalue(L,(lc5 + lc_nextra));
  lua_pushcclosure(L,lcf1_string_to_ast,1);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* local src_filename = ... */
  lua_pushvalue(L,(lc_nformalargs + 1));
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* if not src_filename then */
  enum { lc8 = 17 };
  lua_pushboolean(L,!(lua_toboolean(L,(17 + lc_nextra))));
  const int lc9 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc9) {
    
    /* io.stderr:write("usage: lua2c filename.lua\n") */
    lc_getupvalue(L,(lc5 + lc_nextra),3,2);
    lua_pushliteral(L,"stderr");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"write");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"usage: lua2c filename.lua\n");
    lua_call(L,2,0);
    assert(lua_gettop(L) - lc_nextra == 17);
    
    /* os.exit(1) */
    lua_pushliteral(L,"exit");
    lua_gettable(L,(6 + lc_nextra));
    lua_pushnumber(L,1);
    lua_call(L,1,0);
    assert(lua_gettop(L) - lc_nextra == 17);
  }
  lua_settop(L,(lc8 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* -- Generate output filename by replacing .lua extension with .c
   * local output_filename = src_filename:gsub("%.lua$", "") .. ".c" */
  lua_pushvalue(L,(17 + lc_nextra));
  lua_pushliteral(L,"gsub");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"%.lua$");
  lua_pushliteral(L,"");
  lua_call(L,3,1);
  lua_pushliteral(L,".c");
  lua_concat(L,2);
  assert(lua_gettop(L) - lc_nextra == 18);
  
  /* local src_file = assert(io.open (src_filename, 'r')) */
  lua_pushvalue(L,(2 + lc_nextra));
  const int lc10 = lua_gettop(L);
  lc_getupvalue(L,(lc5 + lc_nextra),3,2);
  lua_pushliteral(L,"open");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(17 + lc_nextra));
  lua_pushliteral(L,"r");
  lua_call(L,2,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc10),1);
  assert(lua_gettop(L) - lc_nextra == 19);
  
  /* local src = src_file:read '*a' */
  lua_pushvalue(L,(19 + lc_nextra));
  lua_pushliteral(L,"read");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"*a");
  lua_call(L,2,1);
  assert(lua_gettop(L) - lc_nextra == 20);
  
  /* src_file:close() */
  lua_pushvalue(L,(19 + lc_nextra));
  lua_pushliteral(L,"close");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 20);
  
  /* src = src:gsub('^#[^\r\n]*', '') */
  lua_pushvalue(L,(20 + lc_nextra));
  lua_pushliteral(L,"gsub");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"^#[^\r\n]*");
  lua_pushliteral(L,"");
  lua_call(L,3,1);
  lua_replace(L,(20 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 20);
  
  /* -- remove any shebang
   * local ast = string_to_ast(src) */
  lua_pushvalue(L,(16 + lc_nextra));
  lua_pushvalue(L,(20 + lc_nextra));
  lua_call(L,1,1);
  assert(lua_gettop(L) - lc_nextra == 21);
  
  /* local cast = A2C.ast_to_cast(src, ast) */
  lua_pushliteral(L,"ast_to_cast");
  lua_gettable(L,(12 + lc_nextra));
  lua_pushvalue(L,(20 + lc_nextra));
  lua_pushvalue(L,(21 + lc_nextra));
  lua_call(L,2,1);
  assert(lua_gettop(L) - lc_nextra == 22);
  
  /* -- DEBUG(cast)
   * -- Write output to file instead of stdout
   * local output_file = assert(io.open(output_filename, 'w')) */
  lua_pushvalue(L,(2 + lc_nextra));
  const int lc11 = lua_gettop(L);
  lc_getupvalue(L,(lc5 + lc_nextra),3,2);
  lua_pushliteral(L,"open");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,(18 + lc_nextra));
  lua_pushliteral(L,"w");
  lua_call(L,2,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc11),1);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* output_file:write(C2S.cast_to_string(cast)) */
  lua_pushvalue(L,(23 + lc_nextra));
  const int lc12 = lua_gettop(L);
  lua_pushliteral(L,"write");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"cast_to_string");
  lua_gettable(L,(13 + lc_nextra));
  lua_pushvalue(L,(22 + lc_nextra));
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc12),0);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* output_file:close() */
  lua_pushvalue(L,(23 + lc_nextra));
  lua_pushliteral(L,"close");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* -- Print a message to stdout to indicate success
   * io.stdout:write("Generated " .. output_filename .. "\n") */
  lc_getupvalue(L,(lc5 + lc_nextra),3,2);
  lua_pushliteral(L,"stdout");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"write");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"Generated ");
  lua_pushvalue(L,(18 + lc_nextra));
  lua_pushliteral(L,"\n");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 23);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


static int lc_pmain(lua_State * L) {
  luaL_openlibs(L);

  const lc_args_t * const args = (lc_args_t*)lua_touserdata(L, 1);
  lc_createarg(L, args);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);
  int i;
  for (i=1; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
  }
  int status2 = lua_pcall(L, args->c-1, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


int main(int argc, const char ** argv) {
  lc_args_t args = {argc, argv};
  lua_State * L = luaL_newstate();
  if (! L) { fputs("Failed creating Lua state.", stderr); exit(1); }

  int status = lua_cpcall(L, lc_pmain, &args);
  if (status != 0) {
    fputs(lua_tostring(L,-1), stderr);
  }

  lua_close(L);
  return 0;
}


